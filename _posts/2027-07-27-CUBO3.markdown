---
layout: post
title: "orbit"
date: 2025-07-27
---
CUBO3

<script>
      var mathbox = MathBox.mathBox({
        plugins: ["core", "controls", "cursor", "mathbox"],
        controls: {
          // Orbit controls, i.e. Euler angles, with gimbal lock
          klass: THREE.OrbitControls,

          // Trackball controls, i.e. Free quaternion rotation
          //klass: THREE.TrackballControls,
        },
      });
      if (mathbox.fallback) throw "WebGL not supported";

      var three = mathbox.three;
      three.renderer.setClearColor(new THREE.Color(0xffffff), 1.0);
  
      var camera =
      mathbox
      .camera({
        proxy: true,
        position: [0, 0, 3],
      });

          // 2D cartesian
    var view =
      mathbox
      .cartesian({
        range: [[-15, 15], [-15, 15], [-15, 15]],
        scale: [2, 1, 1],
      });

    // Axes + grid
    view
      .axis({
        axis: 1,
        width: 3,
      })
      .axis({
        axis: 2,
        width: 3,
      })
      .grid({
        width: 2,
        divideX: 20,
        divideY: 10,
      });

      // Make axes black
    mathbox.select('axis').set('color', 'black');

      // Calibrate focus distance for units
    mathbox.set('focus', 3);

let L_value = 15;
// factor: how many points per 1 unit distance
let factor = 4;
let n_value = 4;
let l_value = 2;
let m_value = 0;
      
let minimum_percent = 0.00001;
// you'll need to change the L_value accordingly when changing the value below
let bohr_radius_value = 0.529177;

// the (assodiated) Laguerre polynomial
const laguerrePolynomial = (n, k, x) => {
  const equation = (m) => {
    return (
      (factorialize(n + k) /
        (factorialize(n - m) * factorialize(k + m) * factorialize(m))) *
      x ** m *
      (-1) ** m
    );
  };
  return sigma(equation, 0, n);
};

// sigma
const sigma = (equation, i, n) => {
  let sum = 0;
  while (i <= n) {
    sum += equation(i);
    i++;
  }
  return sum;
};

// factorialize input
const factorialize = (x) => {
  if (x < 0) {
    return -1;
  } else if (x === 0) {
    return 1;
  } else {
    return x * factorialize(x - 1);
  }
};

// the spherical harmonics
const sphericalHarmonics = (l, m, theta, phi) => {
  if (m > 0) {
    return (
      Math.sqrt(
        ((2 * l + 1) * factorialize(l - m)) /
          (4 * Math.PI * factorialize(l + m))
      ) *
      legendrePolynomial(l, m, Math.cos(theta)) *
      Math.sin(m * phi)
    );
  } else {
    return (
      Math.sqrt(
        ((2 * l + 1) * factorialize(l - m)) /
          (4 * Math.PI * factorialize(l + m))
      ) *
      legendrePolynomial(l, m, Math.cos(theta)) *
      Math.cos(m * phi)
    );
  }
};

//the Legendre polynomials
const legendrePolynomial = (l, m, x) => {
  const equation = (x) => {
    return (x ** 2 - 1) ** l;
  };
  return (
    ((-1) ** m / (2 ** l * factorialize(l))) *
    (1 - x ** 2) ** (m / 2) *
    highOrderDerivative(equation, l + m, x)
  );
};
// nth deriviation
const highOrderDerivative = (equation, order, x) => {
  let i = 1;
  let deriviation = equation;
  while (i < order) {
    deriviation = derivative(deriviation);
    i++;
  }
  if (order === 0) {
    return 1;
  } else {
    return derivative(deriviation)(x);
  }
};

// deriviation
const derivative = (f) => {
  var h = 0.001;
  return function (x) {
    return (f(x + h) - f(x - h)) / (2 * h);
  };
};

//3. finally, a function that gives us the wave function
const waveFunction = (n, l, m, r, theta, phi) => {
  const rho = (2 * r) / (n * bohrRadius());
  return (
    Math.sqrt(
      ((2 / (n * bohrRadius())) ** 3 * factorialize(n - l - 1)) /
        (r * 2 * n * factorialize(n + l))
    ) *
    Math.E ** (rho / -2) *
    rho ** l *
    laguerrePolynomial(n - l - 1, 2 * l + 1, rho) *
    sphericalHarmonics(l, m, theta, phi)
  );
};

// the bohr radius, represented by a0
const bohrRadius = () => {
  //return 1;
  return bohr_radius_value;
};

const radius = (x, y, z) => {
  return Math.sqrt(x ** 2 + y ** 2 + z ** 2);
};

const theta = (x, y, z) => {
  return Math.acos(z / radius(x, y, z));
};

const phi = (y, x) => {
  return Math.atan(y / x);
};

// creates points from [-L,-L,-L] to [L,L,L]
const getTrace = () => {
  let data = {
    x: [],
    y: [],
    z: []
  };
  let maximum = 0;
  let minimum = 1;
  let i = -1 * L_value * factor;
  while (i < L_value * factor) {
    let t = -1 * L_value * factor;
    while (t < L_value * factor) {
      let s = -1 * L_value * factor;
      while (s < L_value * factor) {
        let percent =
          waveFunction(
            n_value,
            l_value,
            m_value,
            radius(i / factor, t / factor, s / factor),
            theta(i / factor, t / factor, s / factor),
            phi(t / factor, i / factor)
          ) ** 2;
        if (percent > minimum_percent) {
          data.x.push(i / factor);
          data.y.push(t / factor);
          data.z.push(s / factor);
        }
        if (percent > maximum) {
          maximum = percent;
        }
        if (percent < minimum && percent !== 0) {
          minimum = percent;
        }
        s += 1;
      }
      t += 1;
    }
    i += 1;
  }

  return data;
};

const newTrace = () => {
  let object_data = getTrace();
  let x_data = object_data.x;
  let y_data = object_data.y;
  let z_data = object_data.z;
  return {
    x: x_data,
    y: y_data,
    z: z_data,
    mode: "markers",
    marker: {
      color: "rgb(66, 135, 245)",
      size: 1,
      symbol: "circle",
      opacity: 0.6
    },
    type: "scatter3d"
  };
};

let graphDiv = document.getElementById("graph");

function loadGraph() {
var layout = {
  margin: {
    l: 0,
    r: 0,
    b: 0,
    t: 0
  }
};
Plotly.newPlot(graphDiv, [newTrace()], layout);
}

var data =
      view
      .volume({
        expr: function (emit, x,y,z) {
            let maximum = 0;
  let minimum = 1;
        let percent =
          waveFunction(
            n_value,
            l_value,
            m_value,
            radius(x, y, z),
            theta(x, y, z),
            phi(y, x)
          ) ** 2;
        if (percent > minimum_percent) {
          emit(x, y, z);
        }
        if (percent > maximum) {
          maximum = percent;
        }
        if (percent < minimum && percent !== 0) {
          minimum = percent;
        }
        },
        width: 64,
        height: 64,
        depth: 64,
        channels: 3,
      });

      var points =
  view.point({
    size: 8,
    color: '#3090FF',
  });
  /*
      // Add some data
    var data =
      view
      .interval({
        expr: function (emit, x, i, t) {
          emit(x, Math.sin(x + t));
        },
        width: 64,
        channels: 2,
      });

    // Draw a curve
    var curve =
      view
      .line({
        width: 5,
        color: '#3090FF',
      });

      var points =
  view.point({
    size: 8,
    color: '#3090FF',
  });
*/

    var data1 =
      view
      .interval({
        expr: function (emit, x, i, t) {
              if (x > 0) {
          emit(x, Math.sin(x + t));
        }
          //emit(x, Math.sin(x + t));
        },
        width: 2,
        channels: 2,
      });

      var points1 =
  view.point({
    size: 8,
    color: '#50A000',
  });

      /*
      var data2 =
      view
      .interval({
        expr: function (emit, x, i, t) {
         const phi = x * 2 * Math.PI;
          emit(Math.cos(t+phi), Math.sin(t+phi), 0);
        },
        width: 64,
        channels: 3,
      });

      var points2 =
  view.point({
    size: 8,
    color: '#50A000',
  });

        var data4 =
      view
      .interval({
        expr: function (emit, x, i, t) {
         const phi = x * 2 * Math.PI;
         const theta = Math.PI/4;
          emit(Math.sin(theta)*Math.cos(t+phi), Math.sin(theta)*Math.sin(t+phi), Math.cos(theta));
        },
        width: 64,
        channels: 3,
      });

      var points4 =
  view.point({
    size: 8,
    color: '#50A000',
  });

          var data5 =
      view
      .area({
        expr: function (emit, u, v, i, j, t) {
          const theta = u * Math.PI;       // [0, π]
          const phi = v * 2 * Math.PI;     // [0, 2π]
          const r = 1;

          const x = r * Math.sin(theta) * Math.cos(phi+t);
          const y = r * Math.sin(theta) * Math.sin(phi+t);
          const z = r * Math.cos(theta);
          emit(x, y, z);
        },
        width: 32,
        height: 16,
        channels: 3,
      });

      var points5 =
  view.point({
    size: 8,
    color: '#50A000',
  });

        var data3 =
      view
      .interval({
        expr: function (emit, x, i, t) {
          emit(0, 0, Math.sin(t));
        },
        width: 1,
        channels: 3,
      });

      var points3 =
  view.point({
    size: 8,
    color: '#50A000',
  });
*/
  
  /*
      var vector =
  view.interval({
    expr: function (emit, x, i, t) {
      emit(x, 0);
      emit(x, -Math.sin(x + t));
    },
    width: 64,
    channels: 2,
    items: 2,
  })
  .vector({
    end: true,
    width: 5,
    color: '#50A000',
  });
*/

       var scale =
  view.scale({
    divide: 10,
  });

      var ticks =
  view.ticks({
    width: 5,
    size: 15,
    color: 'black',
  });

      var format =
  view.format({
    digits: 2,
    weight: 'bold',
  });

      var labels =
  view.label({
    color: 'red',
    zIndex: 1,
  });

</script>
